### 🧑‍💻Context 문제 발생 코드🧑‍💻
~~~kotlin
class MyApplication: Application() {
   
        val keyGenParameterSpec = MasterKeys.AES256_GCM_SPEC
        val masterKeyAlias = MasterKeys.getOrCreate(keyGenParameterSpec)

        val sharedPreferences = EncryptedSharedPreferences.create(
            "encryptedLogin",
            masterKeyAlias,
            this,
            EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
            EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
        )
    }
~~~

### 😀Context 문제 해결 코드😀
~~~kotlin
class MyApplication : Application() {

    lateinit var sharedPreferences: SharedPreferences
        private set

    override fun onCreate() {

        super.onCreate()

        val keyGenParameterSpec = MasterKeys.AES256_GCM_SPEC
        val masterKeyAlias = MasterKeys.getOrCreate(keyGenParameterSpec)

        sharedPreferences = EncryptedSharedPreferences.create(
            "encryptedLogin",
            masterKeyAlias,
            this,
            EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
            EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
        )
    }
}
~~~

### 📌문제가 발생했던 이유📌

* 만일 전자의 코드를 실행하면 Context 오류가 발생한다.
* 이유는 Application class가 Context를 상속받기 이전에 SharedPreference 객체가 생성될 수 있기 때문이다.
</br>
---

⬇️아래의 대화로 좀더 잘 이해해보자⬇️
~~~
🧑‍⚕️:오늘은 축구하는 날이지, 축구하러 가자.
👩‍⚕️:근데...축구공은 가져가야지 이 x끼야
~~~

이런 느낌이다. 축구를 하는게 목적인데, 축구공을 아직 받지 않은거다. 그러면 축구를 못하겠지? 그러면 당연히 곤란해진다(에러가 발생한다)

그래서 onCreate()문 안에 SharedPreference 객체를 선언하면 안전하게 Context를 상속받고, 그 다음에 그 Context를 사용해서 Preference객체를 선언할 수 있다.
이걸 몰라서 1시간 반 정도 머리를 쥐어짜내셔 고생했다....🤬
