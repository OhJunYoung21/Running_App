# 아이디 중복확인은 비동기작업으로(코루틴 사용)

~~~kotlin
suspend fun checkId(id:String):Boolean {

        return withContext(Dispatchers.IO){

            db.getUserDAO().getIdList().contains(id)
        }
    }
~~~

<div>내가 원하는 기능은 아이디가 이미 데이터베이스에 있는지 유무가 궁금한 것이다. 그러려면 일단, 데이터베이스에 접근해야 하는데 DB(Database)에 접근하는 작업은 Main Thread에서 일어나지 않는다.</div>
즉, 다른 스레드에서 실행해줘야 하는데 그러려면 코루틴이라는 강력한 무기를 사용하는 방법이 있다. 코루틴은 쉽게 말하면 비동기작업을 처리해주는 공간 또는 기능이라고 생각하면 된다. 코루틴 내부에서 함수를 수행하려면 그 함수는 
위의 코드처럼 suspend를 앞에 붙여줘야 한다. suspend가 붙어있지 않으면 해당 함수를 코루틴에서 사용할 수 없다. suspend가 붙은 함수를 본다면, 아, 해당 함수는 코루틴 내부에서 사용하겠구나 정도로 지금은 이해하면 될 듯하다.😀


## 실제 사용 예시

~~~kotlin
binding.checkId.setOnClickListener {

            id = binding.userId.text.toString()

            lifecycleScope.launch{

                val idExist = checkId(id)

                if(idExist){
                    withContext(Dispatchers.Main){

                        Toast.makeText(this@JoinActivity,"아이디가 이미 존재합니다.",Toast.LENGTH_SHORT).show()

                    }
                }
            }
        }
~~~

위 함수의 작동단계는 아래와 같다.
* checkId라는 식별자를 가진 뷰 객체를 클릭한다
* 지연초기화로 선언한 id에 값을 할당한다.
* lifeCycleScope.launch{ }, 코루틴을 의미한다. 해당 괄호안에 들어가는 작업은 코루틴 안에서 진행한다는 의미이다.
* idExist에는 Boolean(참,거짓)형의 변수가 들어가게 되며, 참인 경우에는 토스트 메세지를 출력한다.

